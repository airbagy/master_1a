---
title: "STA 3431 Assignment #2"
author: "Yihan Duan"
date: "26/10/2021"
output: pdf_document
---

Name: Yihan Duan
Student #: 1003118547
Department: CS
Program: MScAC
Year: first year master
E-mail: yihan.duan@mail.utoronto.ca

## Question 1

First let's take a look at the target density function. Because $-\frac{-x^4}{6} \le 0$ on $R$, and $e^x$ is increasing on $R^-$, we know the target density function should be larger around 0 and should get smaller further away from 0. Let's verify that.

```{R}
g = function(x) {
  return(exp(-x^4/6))
}

curve(g, from=-5, to=5)
```

As we can see, the value for g(x) drops drastically around -3 and 3. As MCMC works better if the initial value covers the "important" parts of the state space, we choose $X_0$ using a uniform distribution $U(-3, 3)$.

### $\sigma^2 = 1$

First lets try $\sigma = 1$. Let's choose $X_0 = 3$ and run it for 1000 iterations to see decide on burn-in.

```{R}
# define h here
h = function(y) { return(y^2) }

# parameters
N = 1000
X = 3
sigma = 1
xlist = rep(0, N)
hlist = rep(0, N)

for (i in 1:N) {
  Y = X + sigma * rnorm(1)
  U = runif(1)
  alpha = g(Y) / g(X)
  if (U < alpha) {
    X = Y
  }
  xlist[i] = X
  hlist[i] = h(X)
}

plot(xlist, type='l')
```

It seems like not much burn in is needed before it becomes stable. Let's set the number of burn-in's to be 1000 just to be safe. 

Now let's see what's the best choice for 'lag.max' in 'acf' function.

```{R}
acf(hlist)
```

Looks like our 'acf' becomes very small at around 10. Let's try to automate this process.

```{R}
get_lag_max <- function(hlist) {
  N = length(hlist)
  acfs = acf(hlist, plot=FALSE, lag.max=N)$acf
  for (i in 1:N) {
    if (acfs[i] < 0.01) {
      return(i)
    }
  }
  return(N)
}

get_lag_max(hlist)
```

Now lets start a real run.

```{R}
set.seed(1234) 

run_MCMC <- function(M, B, sigma, print_result=TRUE) {
  X = runif(n=1, min=-3, max=3)  # overdispersed starting distribution
  xlist = rep(0,M)  # for keeping track of chain values
  hlist = rep(0,M)  # for keeping track of h function values
  numaccept = 0
  
  for (i in 1:M) {
    Y = X + sigma * rnorm(1)  # proposal value
    U = runif(1)  # for accept/reject
    alpha = g(Y) / g(X)  # for accept/reject
    if (U < alpha) {
      X = Y  # accept proposal
      numaccept = numaccept + 1
    }
    xlist[i] = X
    hlist[i] = h(X)
  }
  
  u = mean(hlist[(B+1):M])
  
  if (print_result) {
    cat("ran Metropolis algorithm for", M, "iterations, with burn-in", B, "\n")
    cat("acceptance rate =", numaccept/M, "\n")
    cat("mean of h is about", u, "\n")
    se1 =  sd(hlist[(B+1):M]) / sqrt(M-B)
    cat("iid standard error would be about", se1, "\n")
    
    varfact <- function(xxx) { 2 * sum(acf(xxx, plot=FALSE, lag.max=get_lag_max(hlist))$acf) - 1 }
    thevarfact = varfact(hlist[(B+1):M])
    se = se1 * sqrt( thevarfact )
    cat("varfact = ", thevarfact, "\n")
    cat("true standard error is about", se, "\n")
    cat("approximate 95% confidence interval is (", u - 1.96 * se, ",",
        u + 1.96 * se, ")\n\n")
  }
  
  return(list(xlist, hlist, u))
}
result = run_MCMC(11000,1000,1)
```

We can see that the acceptance rate is higher than the optimal but still quite good. The varfact and standard error is a little high and the confidence interval is wider then we would like. We can further reduce this by increasing the number of samples. 

Let's see the mixing of the samples. We will choose the first 1000 samples to investigate.

```{R}
plot(result[[1]][1001:2000], type='l')
```

They seems to be mixing really well. The value doesn't stay unchanged for a long time and stays

Now let's re-run the algorithm for a few times and see the accuracy.

```{R}
set.seed(1234)
estimates = c(20)
for (i in 1:20) {
  estimates[i] = run_MCMC(11000,1000,1,FALSE)[[3]]
}

cat("The estimates are:\n")
estimates
cat("Mean: ", mean(estimates), "\n")
cat("Standard error: ", sd(estimates)/sqrt(20))
```

As we can see most of the estimates for h are between 0.82 and 0.84. However, there are still occasional estimates that are way off like 0.79. This algorithm is moderately accurate.

### $\sigma^2 = 2$

```{R}
result = run_MCMC(11000,1000,5,TRUE)
```


